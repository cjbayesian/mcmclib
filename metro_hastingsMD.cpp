#include "metro_hastingsMD.h"

#define MATHLIB_STANDALONE 1
#include <Rmath.h>

namespace mcmcMD
{
//####################################################################################################################################################################
// takes <iterations> MCMC samples by calling the M-H algorithm in n dimensional space
// Samples using an adaptive multivariate normal proposal 

// USAGE: run_mcmc(<a vector of seed values>, 
//          <a vector of proposal density widths>, 
//          <function call to your likelihood function>, 
//          <function call to your prior function>,
//          <function call defining illegal parameter values>, 
//          <length of MCMC chain>, 
//          <length of burn-in phase>, 
//          <take every {thin}th sample to reduce autocorrelation>, 
//          <output filename>
//          <header T/F>
//          <verbos T/F>
//          <resample T/F - if stochastic likelihood>
//          <length of adapatation phases>
//          <number of adaptation phases>)
//####################################################################################################################################################################
bool append=false;
void STDCALL run_mcmc(_vbc_vec<float> param_seeds, 
   _vbc_vec<float> proposal_width, 
   void (STDCALL *likelihood)(_vbc_vec<float>* ,float* ,int),
   float (STDCALL *prior)(_vbc_vec<float> ,int), 
   bool (STDCALL *restrictions)(_vbc_vec<float>), 
   int iterations, 
   int burn_in, 
   int thin, 
   const char * filename,
   bool header,
   bool verbose,
   bool resample,
   int adapt_l,
   int adapt_n)
{
	struct tm *current;	//for printing progress times
	time_t now;

	cout.precision(5);
	int onescount(0);
	int dimensions;
	dimensions = param_seeds.UBound();
	int point(1);
	int vartrackLength = adapt_l; 	//VARIABLE LENGTHS OF ADAPTIVE PHASES	
	_vbc_vec<float> sample_mean(1,dimensions);
	_vbc_vec<float> sample_var(1,dimensions,1,dimensions);
	_vbc_vec<float> sum_x(1,dimensions);
	_vbc_vec<float> sum_dx(1,dimensions);
	_vbc_vec<float> sum_dxy(1,dimensions,1,dimensions);

	float PI_X(-1000000);

	for (int i =1; i<=dimensions; i++)  //initialise values used for aptaptive phases
	{
      sample_mean(i) = 0;
      sum_dx(i) = 0;
      sum_x(i) = 0;
	   for (int j =1; j<=dimensions; j++) 
	   {
		   sample_var(i,j) = 0;
		   sum_dxy(i,j) = 0;
      }
	}

//*************prepare output file with naming convention*************************	

	ofstream outfile;
	if(append)
		outfile.open(filename,ios::app);
	else
		outfile.open(filename);

   string log_filename(filename);
   log_filename = log_filename + ".log"; 
	ofstream logfile;
   if(append)
		logfile.open(log_filename.c_str(),ios::app);
	else
		logfile.open(log_filename.c_str());

	time(&now);
	current = localtime(&now);

	if(header)
	{
		logfile << "# MCMC runs generated by Metropolis Hastings Algorithm \n# Corey Chivers 2012 - McGill University \n#\n";
		logfile << "# Generated on: " << current->tm_mday << " " << current->tm_mon << ", " << current->tm_year << " at " 
			<< current->tm_hour << ":" << current->tm_min << "\n";
		logfile << "# seeds:\n# " ;
	
		for (int dim = 1; dim <=dimensions; dim++)
		{
			logfile << param_seeds(dim) << "|";
		}
		logfile << "\n# proposal widths:\n# ";
		for (int dim = 1; dim <=dimensions; dim++)
		{
		   for (int dim2 = 1; dim2 <=dimensions; dim2++)
			   logfile << proposal_width(dim,dim2) << "|";
         logfile << "\n# ";
		}
		logfile << "\n# burn-in: " << burn_in << "\n# thin: " << thin << "\n#\n#\n";
	}
   logfile.close();
//***********************************************************************************

	if (param_seeds.UBound() != proposal_width.UBound())
	{			
		cerr << "Please provide proposal distribution widths for all parameters\n";
		throw _vbc_UDTError();	
	}
//*********************************start chain***************************************
   int n=0;
   int n_adapt=1;
	for (int i = 1; i <= iterations; i++)
	{

      ////////////////////////////////////
		mh_base(&param_seeds, proposal_width, dimensions, likelihood, prior, restrictions,&PI_X,resample); //an individual markov-step
      ////////////////////////////////////


		//***************Proposal Adaptations************************//
			if (i>burn_in && i < burn_in + adapt_n*vartrackLength)
			{	
            n++;
				var_track(&param_seeds, &sample_mean, &sample_var, &sum_x, &sum_dxy, dimensions, n);
			}
			if (i == burn_in + n_adapt*vartrackLength && n_adapt <= adapt_n)
			{
            logfile.open(log_filename.c_str(),ios::app);
            if(is_pos_def(dimensions, sample_var))
				{
               proposal_width = sample_var;
               logfile << "\nProposal covariance matrix update " << n_adapt<< ":\n";
               for (int dim = 1; dim <=dimensions; dim++)
         		{
                  logfile << "\n | ";
		            for (int dim2 = 1; dim2 <=dimensions; dim2++)
			            logfile << proposal_width(dim,dim2) << " | ";
		         }
               logfile << "\n";
            }else{
               logfile << "\nNot Possitive Definate " << n_adapt<<":\n";
            }
            n_adapt++;
            //re-initialise values used for adaptive algorithm
            n=0;
	         for (int j =1; j<=dimensions; j++)
	         {
		         sample_mean(j) = param_seeds(j);
               sum_dx(j) = 0;
               sum_x(j) = 0;
               for (int k =1; k<=dimensions; k++) 
         		   sum_dxy(j,k) = 0;
	         }
            logfile.close();
			}
		//***********************************************************/
	
		
		if (i > burn_in && i%thin==0) //burn-in and take every <thin>th value to minimize autocorrelation correlation
		{
			outfile << point << "\t"; //for input formatted for density script (hist.py)
			for (int k = 1; k <=dimensions; k++)
				outfile << (param_seeds)(k) << "\t";
			outfile << PI_X << "\n";
			point++;
		}

		if (i % (iterations/10) == 0 && verbose)
		{
			time(&now);
			current = localtime(&now);
			cout << 100 * float(i) / float(iterations) 
            << "%\ttime: " 
            << current->tm_hour 
            << ":" << current->tm_min 
            << ":" << current->tm_sec << "\n";
		}	
	}
	outfile.close();
   logfile.close();
//************************************************************************************
}


//One step of the M-H algorithm
void mh_base(_vbc_vec<float> *params, 
   _vbc_vec<float> proposal_width, 
   int dim, 
   void (STDCALL *likelihood)(_vbc_vec<float>*, float*,int),
   float (STDCALL *prior)(_vbc_vec<float>, int), 
   bool (STDCALL *restrictions)(_vbc_vec<float>),
   float* pi_X,
   bool resample)
{		
	float lhood(0), pi_Y, q_XgivY, q_YgivX, a_X_Y, U;

	_vbc_vec<float> k_X = (*params); //set k_X to current position
	_vbc_vec<float> k_Y;


		k_Y = multinormal_sample ( dim, proposal_width, k_X);
		
		if( !restrictions(k_Y) ) //call restrictions function on the current parameter
		{
		   (*params) = k_Y;
		   likelihood(params,&lhood,1);
		   pi_Y = lhood + prior(k_Y, dim);

		   (*params) = k_X;
         if(resample)
         {
		      likelihood(params,&lhood,0); // resample (for stochastic likelihood models)
		      *pi_X = lhood + prior(k_X, dim);
         }
		   a_X_Y = (pi_Y)-(*pi_X);

		   if (a_X_Y > 0)
			   a_X_Y = 0;

		   U = log(Rnd());
		
		   if (U<=a_X_Y) // Accept
		   {
			   k_X = k_Y;
			   (*params) = k_Y;
			   *pi_X = pi_Y;
		   }
      }			
}

void var_track(_vbc_vec<float> *params, 
   _vbc_vec<float> * mean, 
   _vbc_vec<float> * var,
   _vbc_vec<float> * sx,
   _vbc_vec<float> * dxy, 
   int dim, 
   int n)
{
   for(int i=1;i<=dim;i++)
   {
	   (*sx)(i) += (*params)(i);
	   (*mean)(i) = (*sx)(i)  / n; //update the sample mean
   }
   // Machine formula for tracking the covariance matrix.
	for(int i=1;i<=dim;i++)
   {
      for(int j=1;j<=i;j++)
      {
         (*dxy)(i,j)+= ((*params)(i)-(*mean)(i)) * ((*params)(j)-(*mean)(j));
         (*dxy)(j,i)=(*dxy)(i,j); //symmetric

         (*var)(i,j) = (*dxy)(i,j)/n;
         (*var)(j,i) = (*var)(i,j); //symmetric
      }
   }   
}


_vbc_vec<float> diag(_vbc_vec<float> diag_vec)
{
   int M = diag_vec.UBound();
   _vbc_vec<float> mat(1,M,1,M);
   for(int i=1;i<=M;i++)
   {
      for(int j=1;j<=M;j++)
      {
         if(i==j)
            mat(i,j)=diag_vec(i);
         else
            mat(i,j)=0;            
      }
   }
   return mat;
}


};
